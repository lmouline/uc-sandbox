/*-------------------------------------------------------------------------
Compiler Generator Coco/R,
Copyright (c) 1990, 2004 Hanspeter Moessenboeck, University of Linz
extended by M. Loeberbauer & A. Woess, Univ. of Linz
ported from C# to Java by Wolfgang Ahorner
with improvements by Pat Terry, Rhodes University

This program is free software; you can redistribute it and/or modify it
under the terms of the GNU General Public License as published by the
Free Software Foundation; either version 2, or (at your option) any
later version.

This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

As an exception, it is allowed to write an extension of Coco/R that is
used as a plugin in non-free software.

If not otherwise stated, any source code generated by Coco/R (other than
Coco/R itself) does not fall under the GNU General Public License.
------------------------------------------------------------------------*/
-->begin
package ldas.uc.sandbox.language.parser;

import ldas.uc.sandbox.language.node.*;
import ldas.uc.sandbox.language.LucLanguage;

import com.oracle.truffle.api.source.Source;

import java.util.ArrayList;
import java.util.List;

// Checkstyle: stop
// @formatter:off
public class Parser {
-->constants
    static final boolean _T = true;
    static final boolean _x = false;
    static final int minErrDist = 2;

    int errDist = minErrDist;
    public Token currentToken; // last recognized token
    public Token la; // lookahead token

    public final Scanner scanner;
    public final Errors errors;

    private final LucNodeFactory factory;

    -->declarations

    public Parser(LucLanguage language, Source source) {
        this.scanner = new Scanner(source.getInputStream());
        this.factory = new LucNodeFactory();
        this.errors = new Errors();
    }

    void SynErr(int n) {
        if (this.errDist >= this.minErrDist)
            errors.SynErr(this.la.line, this.la.col, n);
        this.errDist = 0;
    }

    public void SemErr(String msg) {
        if (this.errDist >= this.minErrDist)
            this.errors.SemErr(this.currentToken.line, this.currentToken.col, msg);
        this.errDist = 0;
    }

    void Get() {
        for (;;) {
            this.currentToken = this.la;
            this.la = scanner.Scan();
            if (this.la.kind <= maxT) {
                this.errDist++;
                break;
            }
-->pragmas
            this.la = this.currentToken;
        }
    }

     void Expect(int n) {
        if (this.la.kind == n)
            Get();
        else {
            SynErr(n);
        }
    }

    boolean StartOf(int s) {
        return set[s][this.la.kind];
    }

    void ExpectWeak(int n, int follow) {
        if (this.la.kind == n)
            Get();
        else {
            SynErr(n);
            while (!StartOf(follow))
                Get();
        }
    }

    boolean WeakSeparator(int n, int syFol, int repFol) {
        int kind = this.la.kind;
        if (kind == n) {
            Get();
            return true;
        } else if (StartOf(repFol))
            return false;
        else {
            SynErr(n);
            while (!(set[syFol][kind] || set[repFol][kind] || set[0][kind])) {
                Get();
                kind = this.la.kind;
            }
            return StartOf(syFol);
        }
    }

-->productions

    public void Parse() {
        this.la = new Token();
        this.la.val = "";
        Get();
-->parseRoot
    }

    private static final boolean[][] set = {
-->initialization
    };

    public static LucRootNode parseSL(LucLanguage language, Source source) {
        Parser parser = new Parser(language, source);
        parser.Parse();
        if (parser.errors.errors.size() > 0) {
            StringBuilder msg = new StringBuilder("Error(s) parsing Luc script:\n");
            for (String error : parser.errors.errors) {
                msg.append(error).append("\n");
            }
            throw new LucParserError(msg.toString());
        }
        return parser.factory.getRootNode();
    }

} // end Parser

class Errors {

    protected final List<String> errors = new ArrayList<>();

    protected void printMsg(int line, int column, String msg) {
         String error = "-- line " + line + " col " + column + ": " + msg;
         errors.add(error);
    }

    public void SynErr(int line, int col, int n) {
        String s;
        switch (n) {-->errors
            default:
                s = "error " + n;
                break;
        }
        printMsg(line, col, s);
    }

    public void SemErr(int line, int col, String s) {
        printMsg(line, col, s);
    }

    public void SemErr(String s) {
        errors.add(s);
    }

    public void Warning(int line, int col, String s) {
        printMsg(line, col, s);
    }

    public void Warning(String s) {
        errors.add(s);
    }
} // Errors

class FatalError extends RuntimeException {

    public static final long serialVersionUID = 1L;

    public FatalError(String s) {
        super(s);
    }
}